# Очереди

Очереди сообщений – это форма коммуникации между сервисами. Очереди сообщений позволяют различным частям системы асинхронно взаимодействовать и обрабатывать операции. Чтобы отправить сообщение, компонент, называемый источником (producer), добавляет сообщение в очередь. Сообщение хранится в очереди, пока другой компонент, называемый получателем (consumer), не извлечет это сообщение и не выполнит с ним некую операцию. В этом задании для отработки взаимодействия мы будем использовать два разных приложения! Первое приложение будет источником – при регистрации нового пользователя оно будет добавлять в очередь сообщение, что пользователь с определёнными данными зарегистрирован. Второе приложение будет слушать очередь и обрабатывать полученные сообщения. Обратите внимание, что это действительно два разных приложения, которые не зависят друг от друга. Вы можете запустить и протестировать каждое из них в отдельности.

## Ссылки

* [Установка Docker](https://docs.docker.com/get-docker/)
* [Пример простого приложения с брокером сообщений RabbitMQ](https://spring.io/guides/gs/messaging-rabbitmq/)
* [Метод convertAndSend() – отправляет сообщение в указанный "обменник" с указанным ключом](https://docs.spring.io/spring-amqp/api/org/springframework/amqp/rabbit/core/RabbitTemplate.html#convertAndSend(java.lang.String,java.lang.Object))
* [Аннотация @RabbitListener – позволяет прослушивать очередь сообщений](https://docs.spring.io/spring-amqp/api/org/springframework/amqp/rabbit/annotation/RabbitListener.html)

## Установка RabbitMQ

Так как очереди могут использоваться несколькими производителями и потребителями одновременно, обычно их реализуют с помощью дополнительной системы, называемой брокером. Одним из таких брокеров является RabbitMQ. Для выполнения этой задачи вам потребуется запустить сервер RabbitMQ. Так как локальная установка RabbitMQ является довольно сложной, мы будем запускать сервер RabbitMQ в Docker контейнере.

## Задачи

* Воспользуйтесь инструкцией на официальном сайте и установите Docker для вашей операционной системы.

* Запустите в контейнере сервер RabbitMQ с настройками по умолчанию. Для этого выполните в терминале команду:

```bash
docker run -it --rm --name rabbitmq -p 5600:5672 -p 15670:15672 rabbitmq:3.9-management
```

Дождитесь запуска сервера в контейнере. Пока выполните эту команду как есть. Подробнее о том, что делает она делает, будет рассказано в одном из следующих уроков. Для работы с приложением вам потребуется открыть новое окно в терминале.

## Первое приложение – источник сообщений

## producer/src/main/java/exercise/RabbitMqConfig.java

Для работы с RabbitMQ нам потребуется его сконфигурировать. Для работы нам потребуются следующие бины:

* `queue` – для создания очереди, в которую мы будем посылать сообщения

  ```java
  @Bean
  Queue queue() {
      // Задаём имя очереди
      return new Queue("queue", false);
  }
  ```

* `exchange` – создаёт "обменник", который помещает сообщение в определённую очередь

  ```java
  @Bean
  TopicExchange exchange() {
      // Задаём имя "обменника". Как и имя очереди, оно может быть любым
      return new TopicExchange("exchange");
  }
  ```

* `binding` – связывает очередь с разветвителем и определяет поведение при добавлении нового сообщения в exchange

  ```java
  @Bean
  Binding binding(Queue queue, TopicExchange exchange) {
      // Сообщения с ключом "key" будут направлены в очередь "queue"
      return BindingBuilder.bind(queue).to(exchange).with("key");
  }
  ```

## Задачи

* Добавьте перечисленные бины в класс `RabbitMqConfig`. Задайте имена очереди, обменника и ключа, показанные в примерах, так как они используются в тестах для проверки решения.

## producer/src/main/java/exercise/MessageSender.java

Дальше нам понадобится класс, который будет добавлять сообщения в очередь

## Задачи

* Создайте в классе `MessageSender` метод, который будет отправлять переданное ему текстовое сообщения в созданный нами обменник с определённым ключом. Нужно, чтобы сообщение в итоге попало в созданную нами очередь.

* Для удобства можно добавить в метод вывод логов, чтобы можно было отслеживать в консоли, как происходит отправка сообщений в очередь:

```java
LOGGER.info("Sending message to the queue...");
// Отправка сообщения в очередь
LOGGER.info("Message sent successfully to the queue!!!");
```

## producer/src/main/java/exercise/controller/UserController.java

Мы будем отправлять в очередь сообщения о регистрации нового пользователя и удалении пользователя. Другие приложения смогут получить эти сообщения и использовать по своему усмотрению.

## Задачи

* Допишите методы `createUser()` так, чтобы при регистрации нового пользователя в очередь отправлялось сообщение о регистрации нового пользователя

* Допишите метод `deleteUser()` так, чтобы при удалении пользователя в очередь отправлялось сообщение об удалении пользователя

## Второе приложение – получатель сообщений

Второе приложение будет получать и обрабатывать сообщения из очереди. В этом задании для упрощения приложение будет только выводить полученные сообщения в консоль и добавлять их в список. Но в реальности оно может реагировать на эти сообщения любым образом. Например, отправлять электронные письма или смс об успешной регистрации, если пользователь указал эти данные при регистрации.

## consumer/src/main/java/exercise/RabbitMqConfig.java

Мы должны убедиться, что очередь, из которой приложение будет получать сообщения, существует. Так как мы не можем быть уверены, что приложение-источник будет запущено первым, хорошей практикой будет повторить объявление очереди в приложении-получателе.

## Задачи

* Объявите очередь с именем "queue" по аналогии с приложением-источником.

## consumer/scr/main/java/exercise/QueueListener.java

## Задачи

* В классе `QueueListener` создайте метод, который будет прослушивать очередь и при появлении нового сообщения добавлять это сообщение в список `messages`. Чтобы метод прослушивал сообщения из очереди, нужно отметить его аннотацией `@RabbitListener`, указав имя очереди. В качестве аргумента метод принимает сообщение.

```java
@RabbitListener(queues = "queue")
public void process(String message) {
    // Выполняем какие-то действия
}
```

Метод будет выполнен каждый раз, когда в прослушиваемой очереди появится новое сообщение

* Для наглядности реализуйте логгирование полученного сообщения. Так можно будет увидеть полученное сообщение в консоли.

* Откройте новое окно в терминале и запустите оба приложения при помощи команды `make start` в корне упражнения. Не забудьте предварительно запустить сервер RabbitMQ. Попробуйте зарегистрировать и удалить пользователя. Убедитесь, что в консоль выводятся логи о том, что сообщение было отправлено и получено. Также посмотреть список всех отправленных в очередь сообщений можно будет, отправив GET запрос второму приложению на адрес *localhost:5001/messages*
